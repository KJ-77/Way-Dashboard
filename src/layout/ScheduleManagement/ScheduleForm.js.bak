import React, { useState, useEffect } from 'react'
import {
  CCard,
  CCardBody,
  CCardHeader,
  CForm,
  CFormLabel,
  CFormInput,
  CButton,
  CRow,
  CCol,
  CAlert,
  CSpinner,
  CImage,
  CCloseButton,
  CFormCheck,
  CDropdown,
  CDropdownToggle,
  CDropdownMenu,
  CDropdownItem,
  CListGroup,
  CListGroupItem,
} from '@coreui/react'
import { useNavigate, useParams } from 'react-router-dom'
import { BASE_URL } from '../../config'
import { cilArrowLeft, cilSave } from '@coreui/icons'
import CIcon from '@coreui/icons-react'
import { TextAreaField, ImageUploadField } from '../../components/common'
import { api } from '../../services/api'

const ScheduleForm = () => {
  const navigate = useNavigate()
  const { slug } = useParams()
  const isEditMode = Boolean(slug)

  // Custom styles for dropdown
  const dropdownStyles = {
    maxHeight: '250px',
    overflowY: 'auto',
  }

  const [formData, setFormData] = useState({
    title: '',
    text: '',
    startDate: '',
    endDate: '',
    classTime: '',
    studentCapacity: 1,
    tutors: [], // Initialize as empty array
  })
  const [selectedImages, setSelectedImages] = useState([])
  const [existingImages, setExistingImages] = useState([])
  const [loading, setLoading] = useState(false)
  const [fetchLoading, setFetchLoading] = useState(false)
  const [error, setError] = useState(null)
  const [success, setSuccess] = useState(null)
  const [availableTutors, setAvailableTutors] = useState([])
  const [loadingTutors, setLoadingTutors] = useState(false)

  // Fetch available tutors
  useEffect(() => {
    const fetchTutors = async () => {
      try {
        setLoadingTutors(true)
        const token = localStorage.getItem('admin_token')

        const response = await fetch(`${BASE_URL}/api/tutor`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`,
          },
        })

        if (!response.ok) {
          throw new Error(`HTTP error ${response.status}`)
        }

        const data = await response.json()

        if (data.status === 'success') {
          setAvailableTutors(data.data)
        } else {
          console.warn('Tutors not loaded properly')
        }
      } catch (err) {
        console.error('Error fetching tutors:', err)
      } finally {
        setLoadingTutors(false)
      }
    }

    fetchTutors()
  }, [])

  // Load schedule data if in edit mode
  useEffect(() => {
    if (isEditMode) {
      const fetchSchedule = async () => {
        try {
          setFetchLoading(true)
          const token = localStorage.getItem('admin_token')

          const response = await fetch(`${BASE_URL}/api/schedule/${slug}`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${token}`,
            },
          })

          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`)
          }

          const data = await response.json()

          if (data.success) {
            const schedule = data.data
            // Format dates for date input fields (YYYY-MM-DD format)
            const formatDateForInput = (dateString) => {
              if (!dateString) return ''
              const date = new Date(dateString)
              return date.toISOString().split('T')[0]
            }

            setFormData({
              title: schedule.title || '',
              text: schedule.text || '',
              startDate: formatDateForInput(schedule.startDate),
              endDate: formatDateForInput(schedule.endDate),
              classTime: schedule.classTime || '',
              studentCapacity: schedule.studentCapacity || 1,
              tutors: schedule.tutors || [],
            })
            setExistingImages(schedule.images || [])
          } else {
            throw new Error(data.message || 'Failed to load schedule')
          }
        } catch (err) {
          console.error('Error fetching schedule:', err)
          setError(`Failed to load schedule: ${err.message}`)
        } finally {
          setFetchLoading(false)
        }
      }

      fetchSchedule()
    }
  }, [slug, isEditMode])

  // Handle form input changes
  const handleInputChange = (e) => {
    const { name, value } = e.target
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }))
  }

  // Handle tutor selection with checkbox
  const handleTutorChange = (tutorId) => {
    setFormData((prev) => {
      // Check if tutor is already selected
      const isSelected = prev.tutors.includes(tutorId)

      // If selected, remove it; otherwise, add it
      let updatedTutors
      if (isSelected) {
        updatedTutors = prev.tutors.filter((id) => id !== tutorId)
      } else {
        updatedTutors = [...prev.tutors, tutorId]
      }

      return {
        ...prev,
        tutors: updatedTutors,
      }
    })
  }

  // Check if a tutor is selected
  const isTutorSelected = (tutorId) => {
    return formData.tutors && formData.tutors.includes(tutorId)
  }

  // Select all tutors that match the current filter
  const selectAllFilteredTutors = () => {
    if (!filteredTutors || filteredTutors.length === 0) return

    const filteredIds = filteredTutors
      .map((tutor) => tutor._id)
      .filter((id) => id)
    const currentIds = formData.tutors || []

    // Combine current selections with filtered tutors, removing duplicates
    const combinedIds = [...new Set([...currentIds, ...filteredIds])]

    setFormData((prev) => ({
      ...prev,
      tutors: combinedIds,
    }))
  }

  // Deselect all tutors that match the current filter
  const deselectAllFilteredTutors = () => {
    if (!filteredTutors || filteredTutors.length === 0 || !formData.tutors)
      return

    const filteredIds = filteredTutors
      .map((tutor) => tutor._id)
      .filter((id) => id)
    const currentIds = formData.tutors

    // Remove all filtered IDs from current selection
    const remainingIds = currentIds.filter((id) => !filteredIds.includes(id))

    setFormData((prev) => ({
      ...prev,
      tutors: remainingIds,
    }))
  }

  // Toggle dropdown open/close state
  const [dropdownOpen, setDropdownOpen] = useState(false)

  // Search filter for tutors
  const [tutorSearch, setTutorSearch] = useState('')

  // Filtered tutors based on search
  const filteredTutors = availableTutors
    ? availableTutors.filter(
        (tutor) =>
          tutor &&
          tutor.name &&
          tutor.name.toLowerCase().includes((tutorSearch || '').toLowerCase()),
      )
    : []

  // Check if schedule content is too similar to existing schedules
  const [checkingDuplicate, setCheckingDuplicate] = useState(false)

  const checkForDuplicateContent = async () => {
    try {
      setCheckingDuplicate(true)
      const token = localStorage.getItem('admin_token')

      // Use a lightweight request to check if the content would create a duplicate slug
      const response = await fetch(`${BASE_URL}/api/schedule/check-duplicate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          text: formData.text,
          currentSlug: isEditMode ? slug : null, // If editing, exclude current schedule
        }),
      })

      const data = await response.json()
      return data.isDuplicate
    } catch (err) {
      console.error('Error checking for duplicates:', err)
      // If check fails, allow submission to continue
      return false
    } finally {
      setCheckingDuplicate(false)
    }
  } // Handle image selection for reusable component
  const handleImageChange = (files, errorMessage = null) => {
    if (errorMessage) {
      setError(errorMessage)
      return
    }

    if (files && files.length > 0) {
      setSelectedImages((prev) => [...prev, ...files])
    }
  }

  // Remove all selected images for reusable component
  const handleImageRemove = () => {
    setSelectedImages([])
  }

  // Remove selected image (keep for individual image removal)
  const removeSelectedImage = (index) => {
    setSelectedImages((prev) => prev.filter((_, i) => i !== index))
  }

  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault()
    setError(null)
    setSuccess(null)

    // Validation for all required fields
    if (!formData.title.trim()) {
      setError('Schedule title is required')
      return
    }
    if (!formData.text.trim()) {
      setError('Schedule text is required')
      return
    }
    if (!formData.startDate) {
      setError('Start date is required')
      return
    }
    if (!formData.endDate) {
      setError('End date is required')
      return
    }
    if (!formData.classTime.trim()) {
      setError('Class time is required')
      return
    }
    if (!formData.studentCapacity || formData.studentCapacity < 1) {
      setError('Student capacity must be at least 1')
      return
    }

    try {
      setLoading(true)

      // Create FormData for file upload
      const formDataToSend = new FormData()
      formDataToSend.append('title', formData.title)
      formDataToSend.append('text', formData.text)
      formDataToSend.append('startDate', formData.startDate)
      formDataToSend.append('endDate', formData.endDate)
      formDataToSend.append('classTime', formData.classTime)
      formDataToSend.append('studentCapacity', formData.studentCapacity)

      // Add tutors - append each tutor ID
      if (formData.tutors && formData.tutors.length > 0) {
        formData.tutors.forEach((tutorId) => {
          formDataToSend.append('tutors', tutorId)
        })
      }

      // Add images
      selectedImages.forEach((image, index) => {
        formDataToSend.append('images', image)
      })

      let data
      // Create or update schedule using the api service
      try {
        if (isEditMode) {
          data = await api.putWithFile(`/schedule/${slug}`, formDataToSend)
        } else {
          data = await api.postWithFile('/schedule', formDataToSend)
        }
      } catch (apiError) {
        // Handle specific error cases
        if (apiError.message && apiError.message.includes('409')) {
          throw new Error(
            'A schedule with similar content already exists. Please modify the text content to make it unique.',
          )
        }
        throw apiError
      }

      if (data.success) {
        setSuccess(
          isEditMode
            ? 'Schedule updated successfully!'
            : 'Schedule created successfully!',
        )

        // Reset form if creating new
        if (!isEditMode) {
          setFormData({ text: '' })
          setSelectedImages([])
        }

        // Navigate back to list after a short delay
        setTimeout(() => {
          navigate('/schedule-management')
        }, 1500)
      } else {
        throw new Error(data.message || 'Failed to save schedule')
      }
    } catch (err) {
      console.error('Error saving schedule:', err)
      setError(`Failed to save schedule: ${err.message}`)
    } finally {
      setLoading(false)
    }
  }

  // Handle back navigation
  const handleBack = () => {
    navigate('/schedule-management')
  }

  // NEW: Debug function to inspect data
  const debugData = (data, label) => {
    console.group(`DEBUG: ${label}`)
    console.log('Data:', data)
    if (data && typeof data === 'object') {
      console.log('Type:', Array.isArray(data) ? 'Array' : 'Object')
      console.log('JSON:', JSON.stringify(data))

      if (Array.isArray(data)) {
        data.forEach((item, index) => {
          console.log(`Item ${index}:`, item, typeof item)
        })
      }
    }
    console.groupEnd()
  }

  if (fetchLoading) {
    return (
      <div className="text-center py-5">
        <CSpinner color="primary" />
        <div className="mt-2">Loading schedule...</div>
      </div>
    )
  }

  return (
    <CCard>
      <CCardHeader>
        <CRow>
          <CCol>
            <h5>{isEditMode ? 'Edit Schedule' : 'Create New Schedule'}</h5>
          </CCol>
          <CCol xs="auto">
            <CButton color="light" variant="outline" onClick={handleBack}>
              <CIcon icon={cilArrowLeft} className="me-2" />
              Back to List
            </CButton>
          </CCol>
        </CRow>
      </CCardHeader>
      <CCardBody>
        {error && (
          <CAlert color="danger" dismissible onClose={() => setError(null)}>
            {error}
          </CAlert>
        )}

        {success && (
          <CAlert color="success" dismissible onClose={() => setSuccess(null)}>
            {success}
          </CAlert>
        )}

        <CForm onSubmit={handleSubmit}>
          <CRow>
            <CCol md={8}>
              {/* Title Field */}
              <div className="mb-3">
                <CFormLabel htmlFor="title">Schedule Title</CFormLabel>
                <CFormInput
                  id="title"
                  name="title"
                  value={formData.title}
                  onChange={handleInputChange}
                  placeholder="Enter the schedule title"
                  required
                />
              </div>

              {/* Text Content Field */}
              <div className="mb-3">
                <TextAreaField
                  id="text"
                  name="text"
                  label="Schedule Content"
                  value={formData.text}
                  onChange={handleInputChange}
                  placeholder="Enter the schedule content..."
                  rows={4}
                  required
                />
                <small className="form-text text-muted">
                  This content is used to generate a unique identifier for the
                  schedule. If you receive a conflict error, try making this
                  content more unique.
                </small>
              </div>

              {/* Date Fields Row */}
              <CRow className="mb-3">
                <CCol md={6}>
                  <CFormLabel htmlFor="startDate">Start Date</CFormLabel>
                  <CFormInput
                    type="date"
                    id="startDate"
                    name="startDate"
                    value={formData.startDate}
                    onChange={handleInputChange}
                    required
                  />
                </CCol>
                <CCol md={6}>
                  <CFormLabel htmlFor="endDate">End Date</CFormLabel>
                  <CFormInput
                    type="date"
                    id="endDate"
                    name="endDate"
                    value={formData.endDate}
                    onChange={handleInputChange}
                    required
                  />
                </CCol>
              </CRow>

              {/* Class Time and Capacity Row */}
              <CRow className="mb-3">
                <CCol md={6}>
                  <CFormLabel htmlFor="classTime">Class Time</CFormLabel>
                  <CFormInput
                    id="classTime"
                    name="classTime"
                    value={formData.classTime}
                    onChange={handleInputChange}
                    placeholder="e.g., 10:00 AM - 12:00 PM"
                    required
                  />
                </CCol>
                <CCol md={6}>
                  <CFormLabel htmlFor="studentCapacity">
                    Student Capacity
                  </CFormLabel>
                  <CFormInput
                    type="number"
                    min="1"
                    id="studentCapacity"
                    name="studentCapacity"
                    value={formData.studentCapacity}
                    onChange={handleInputChange}
                    required
                  />
                </CCol>
              </CRow>

              {/* Tutor Selection with Checkboxes */}
              <div className="mb-3">
                <CFormLabel>Assign Tutors</CFormLabel>
                <CDropdown
                  className="w-100"
                  isOpen={dropdownOpen}
                  toggle={() => setDropdownOpen(!dropdownOpen)}
                >
                  <CDropdownToggle
                    color="outline-primary"
                    caret
                    className="w-100 d-flex justify-content-between align-items-center"
                  >
                    <span>
                      {!formData.tutors || formData.tutors.length === 0
                        ? 'Select tutors'
                        : `${formData.tutors.length} tutor${formData.tutors.length > 1 ? 's' : ''} selected`}
                    </span>
                  </CDropdownToggle>
                  <CDropdownMenu className="w-100 p-0">
                    {/* Search input for tutors */}
                    <div className="p-2 border-bottom">
                      <CFormInput
                        size="sm"
                        placeholder="Search tutors..."
                        value={tutorSearch}
                        onChange={(e) => setTutorSearch(e.target.value)}
                      />
                    </div>

                    {loadingTutors ? (
                      <CListGroupItem className="text-center py-3">
                        <CSpinner size="sm" className="me-2" />
                        Loading tutors...
                      </CListGroupItem>
                    ) : availableTutors.length === 0 ? (
                      <CListGroupItem className="text-center py-3">
                        No tutors available
                      </CListGroupItem>
                    ) : filteredTutors.length === 0 ? (
                      <CListGroupItem className="text-center py-3">
                        No tutors match your search
                      </CListGroupItem>
                    ) : (
                      <CListGroup
                        className="tutor-checkbox-list"
                        style={dropdownStyles}
                      >
                        {filteredTutors.map((tutor) => (
                          <CListGroupItem
                            key={tutor._id}
                            className="d-flex align-items-center border-0 px-3 py-2"
                            style={{ cursor: 'pointer' }}
                            onClick={() => handleTutorChange(tutor._id)}
                          >
                            <CFormCheck
                              id={`tutor-${tutor._id}`}
                              checked={isTutorSelected(tutor._id)}
                              onChange={() => {}}
                              label={tutor.name}
                              className="w-100"
                            />
                          </CListGroupItem>
                        ))}
                      </CListGroup>
                    )}
                    {filteredTutors && filteredTutors.length > 0 && (
                      <div className="d-flex justify-content-between align-items-center p-2 border-top">
                        <div className="btn-group">
                          <CButton
                            size="sm"
                            color="light"
                            variant="ghost"
                            onClick={(e) => {
                              e.stopPropagation()
                              selectAllFilteredTutors()
                            }}
                          >
                            Select All
                          </CButton>
                          <CButton
                            size="sm"
                            color="light"
                            variant="ghost"
                            onClick={(e) => {
                              e.stopPropagation()
                              deselectAllFilteredTutors()
                            }}
                          >
                            Deselect All
                          </CButton>
                        </div>
                        <small className="text-muted">
                          {(formData.tutors && formData.tutors.length) || 0} of{' '}
                          {(availableTutors && availableTutors.length) || 0}{' '}
                          selected
                        </small>
                      </div>
                    )}

                    {availableTutors && availableTutors.length > 0 && (
                      <div className="d-flex justify-content-end p-2 border-top">
                        <CButton
                          size="sm"
                          color="link"
                          onClick={(e) => {
                            e.stopPropagation()
                            setFormData((prev) => ({ ...prev, tutors: [] }))
                          }}
                        >
                          Clear all
                        </CButton>
                      </div>
                    )}
                  </CDropdownMenu>
                </CDropdown>
                {formData.tutors && formData.tutors.length > 0 && (
                  <div className="mt-2 d-flex flex-wrap gap-1">
                    {formData.tutors.map((tutorId) => {
                      const tutor =
                        availableTutors &&
                        availableTutors.find((t) => t && t._id === tutorId)
                      return tutor ? (
                        <div
                          key={tutorId}
                          className="badge bg-primary d-flex align-items-center py-2 px-3"
                        >
                          {tutor.name}
                          <CCloseButton
                            className="ms-2"
                            white
                            onClick={() => handleTutorChange(tutorId)}
                          />
                        </div>
                      ) : null
                    })}
                  </div>
                )}
              </div>

              <ImageUploadField
                id="images"
                label="Upload Images (Optional)"
                imagePreview={null}
                onImageChange={handleImageChange}
                onImageRemove={handleImageRemove}
                multiple={true}
                helpText="You can select multiple images. Supported formats: JPG, PNG, GIF, WebP (Max 15MB each)"
              />

              {/* Show existing images in edit mode */}
              {isEditMode && existingImages.length > 0 && (
                <div className="mb-3">
                  <CFormLabel>Current Images</CFormLabel>
                  <div className="row">
                    {existingImages.map((image, index) => (
                      <div key={index} className="col-md-3 col-sm-6 mb-3">
                        <CImage
                          src={`${BASE_URL}${image}`}
                          alt={`Current image ${index + 1}`}
                          className="w-100 rounded"
                          style={{ height: '150px', objectFit: 'cover' }}
                        />
                      </div>
                    ))}
                  </div>
                  <small className="form-text text-muted">
                    Note: Uploading new images will replace all existing images
                  </small>
                </div>
              )}

              {/* Show selected images */}
              {selectedImages.length > 0 && (
                <div className="mb-3">
                  <CFormLabel>Selected Images</CFormLabel>
                  <div className="row">
                    {selectedImages.map((image, index) => (
                      <div
                        key={index}
                        className="col-md-3 col-sm-6 mb-3 position-relative"
                      >
                        <CImage
                          src={URL.createObjectURL(image)}
                          alt={`Selected image ${index + 1}`}
                          className="w-100 rounded"
                          style={{ height: '150px', objectFit: 'cover' }}
                        />
                        <CCloseButton
                          className="position-absolute"
                          style={{ top: '5px', right: '5px' }}
                          onClick={() => removeSelectedImage(index)}
                        />
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </CCol>

            <CCol md={4}>
              <div className="bg-light p-3 rounded">
                <h6 className="mb-3">Schedule Information</h6>
                <div className="mb-2">
                  <strong>Status:</strong>{' '}
                  {isEditMode ? 'Editing' : 'Creating New'}
                </div>
                {isEditMode && (
                  <div className="mb-2">
                    <strong>Slug:</strong> {slug}
                  </div>
                )}
                <div className="mb-2">
                  <strong>Title:</strong> {formData.title || 'Not set'}
                </div>
                <div className="mb-2">
                  <strong>Content Length:</strong> {formData.text.length}{' '}
                  characters
                </div>
                <div className="mb-2">
                  <strong>Class Period:</strong>{' '}
                  {formData.startDate && formData.endDate
                    ? `${formData.startDate} to ${formData.endDate}`
                    : 'Not set'}
                </div>
                <div className="mb-2">
                  <strong>Class Time:</strong> {formData.classTime || 'Not set'}
                </div>
                <div className="mb-2">
                  <strong>Capacity:</strong> {formData.studentCapacity} students
                </div>
                <div className="mb-2">
                  <strong>Assigned Tutors:</strong>{' '}
                  {(formData.tutors && formData.tutors.length) || 0} tutors
                  {formData.tutors && formData.tutors.length > 0 && (
                    <div className="mt-1 ps-2 border-start">
                      {formData.tutors.map((tutorId) => {
                        const tutor =
                          availableTutors &&
                          availableTutors.find((t) => t && t._id === tutorId)
                        return tutor ? (
                          <div key={tutorId} className="small text-muted mb-1">
                            â€¢ {tutor.name}
                          </div>
                        ) : null
                      })}
                    </div>
                  )}
                </div>
                <div className="mb-2">
                  <strong>Images:</strong> {selectedImages.length} selected
                  {isEditMode && existingImages.length > 0 && (
                    <span className="text-muted">
                      {' '}
                      (+ {existingImages.length} current)
                    </span>
                  )}
                </div>
              </div>
            </CCol>
          </CRow>

          <CRow className="mt-4">
            <CCol>
              <div className="d-flex gap-2">
                <CButton type="submit" color="primary" disabled={loading}>
                  {loading ? (
                    <>
                      <CSpinner size="sm" className="me-2" />
                      Saving...
                    </>
                  ) : (
                    <>
                      <CIcon icon={cilSave} className="me-2" />
                      {isEditMode ? 'Update Schedule' : 'Create Schedule'}
                    </>
                  )}
                </CButton>
                <CButton
                  type="button"
                  color="secondary"
                  onClick={handleBack}
                  disabled={loading}
                >
                  Cancel
                </CButton>
              </div>
            </CCol>
          </CRow>
        </CForm>
      </CCardBody>
    </CCard>
  )
}

export default ScheduleForm
